---
title: Tiered Drop
slug: /sdk.erc721tiereddrop
toc_max_heading_level: 2 # Show up to h2 in table of contents (default is up to h3)
---

# ERC721TieredDrop

Functionality available for contracts that implement the
[`IERC721`](/contracts/IERC721) interface and
[`TieredDrop`](/contracts/TieredDrop)
contract.

## claimWithSignature

Use a signature generated by an authorized wallet with the `MINTER` permission to
claim an NFT from the drop.

See [`generate`](#generate) for more information on how to generate a signed payload.

```javascript
// ... Logic to generate signed payload from an authorized wallet (on server-side)

// Use the signed payload to claim an NFT (on client-side)
const txResult = await contract.erc721.tieredDrop.claimWithSignature(
  signedPayload, // Type: TieredDropPayloadWithSignature
);
```

<details>
    <summary>Configuration</summary>
    <div>

#### signedPayload

The signed payload from [`generate`](#generate) function.

Must be of type `TieredDropPayloadWithSignature`.

</div>
</details>

## createBatchWithTier

Lazy mint a new batch of NFTs into a tier.

By default, the NFT metadata is uploaded and pinned to IPFS before lazy minting.
You can override this default behavior by providing a `string` that points to valid
metadata object instead of an object.

The metadata object can either be a string that points to valid metadata that
conforms to the [metadata standards](https://docs.opensea.io/docs/metadata-standards#metadata-structure),
or an object that conforms to the same standards.

```javascript
const txResult = await contract.erc721.tieredDrop.createBatchWithTier(
  [
    {
      name: "Cool NFT #1",
      description: "This is a cool NFT",
      image: "https://example.com/image.png", // URL, IPFS URI, or File object
      // ... Any other metadata you want to include
    },
    {
      name: "Cool NFT #2",
      description: "This is a cool NFT",
      image: "ipfs://...", // URL, IPFS URI, or File object
      // ... Any other metadata you want to include
    },
  ],
  "tier-name", // Name of the tier to add the NFTs to
);
```

<details>
    <summary>Configuration</summary>
    <div>

#### metadatas

An array of strings that point to, or objects that contain
metadata that conforms to the [metadata standards](https://docs.opensea.io/docs/metadata-standards#metadata-structure).

#### tierName

The name of the tier to add the NFTs to.

Must be a `string`.

</div>
</details>

## createDelayedRevealBatchWithTier

The same as [`createBatchWithTier`](#createbatchwithtier), but the batch is uploaded with a delayed
reveal, meaning the NFTs will have placeholder metadata until you [`reveal`](#reveal) them.

```javascript
const txResult =
  await contract.erc721.tieredDrop.createDelayedRevealBatchWithTier(
    {
      name: "Hidden NFT",
      description: "Will be revealed next week!",
    },
    [
      {
        name: "Cool NFT #1",
        description: "This is a cool NFT",
        image: "https://example.com/image.png", // URL, IPFS URI, or File object
        // ... Any other metadata you want to include
      },
      {
        name: "Cool NFT #2",
        description: "This is a cool NFT",
        image: "ipfs://...", // URL, IPFS URI, or File object
        // ... Any other metadata you want to include
      },
    ],
    "my secret password", // Password to reveal the NFTs
    "tier-name", // Name of the tier to add the NFTs to
  );
```

<details>
    <summary>Configuration</summary>
    <div>

#### placeholder

The placeholder metadata to use for the NFTs until they are revealed.

Must be an object that conforms to the [metadata standards](https://docs.opensea.io/docs/metadata-standards#metadata-structure).

#### metadatas

An array of strings that point to, or objects that contain
metadata that conforms to the [metadata standards](https://docs.opensea.io/docs/metadata-standards#metadata-structure).

#### password

The password to [`reveal`](#reveal) the batch of NFTs.

:::warning Unrecoverable
Passwords cannot be recovered or reset. If you forget your password, you will not be able to reveal your NFTs.
:::

</div>
</details>

## generate

Generate a signed payload that can be used to claim an NFT from the drop.

```javascript
const txResult = await contract.erc721.tieredDrop.generate({
  tierPriority: ["tier-name"], // (Required) the tier(s) to allow the user to claim from
  to: "{{wallet_address}}", // (Required) the wallet to mint the tokens to
  currencyAddress: "{{currency_contract_address}}", // (Optional) the currency to pay with
  price: 0.5, // (Optional) the price to pay for minting those tokens (in the currency above)
  mintStartTime: new Date(), // (Optional) can mint anytime from now
  mintEndTime: new Date(Date.now() + 60 * 60 * 24 * 1000), // (Optional) to 24h from now,
  primarySaleRecipient: "0x...", // (Optional) custom sale recipient for this token mint
  quantity: "{{quantity}}", // (Optional) the quantity to mint
  royaltyBps: 100, // (Optional) the royalty fee on secondary sales (in bps: i.e. 100 = 1%)
  royaltyRecipient: "{{wallet_address}}", // (Optional) the royalty recipient on secondary sales
});
```

<details>
    <summary>Configuration</summary>
    <div>

The `mintRequest` object you provide to the `generate` function outlines what the signature can be used for.

The `tierPriority`, `to` fields are required, while the rest are optional.

#### tierPriority (required)

The tier(s) to allow the user to claim from.

The array of tiers is used in order of rarity, i.e. On claiming,
the contract will try to give the claimer as many NFTs from the first-priority tier,
and only then move down the priority list once that tier is exhausted.

```javascript
const signature = await contract.erc721.tieredDrop.generate({
  // highlight-next-line
  tierPriority: ["tier-name"],
  to: "{{wallet_address}}",
});
```

#### to (required)

The wallet address that can use this signature to mint tokens.

This is to prevent another wallet from intercepting the signature
and using it to mint tokens for themselves.

```javascript
const signature = await contract.erc721.tieredDrop.generate({
  tierPriority: ["tier-name"],
  // highlight-next-line
  to: "{{wallet_address}}",
});
```

#### currencyAddress (optional)

The address of the currency to pay for minting the tokens (use the [`price`](#price-optional) field to specify the price).

Defaults to `NATIVE_TOKEN_ADDRESS` (the native currency of the network, e.g. Ether on Ethereum).

```javascript
const signature = await contract.erc721.tieredDrop.generate({
  tierPriority: ["tier-name"],
  to: "{{wallet_address}}",
  // highlight-next-line
  currencyAddress: "{{currency_contract_address}}",
});
```

#### price (optional)

If you want the user to pay for minting the tokens, you can specify the price **per token**.

Defaults to `0` (free minting).

```javascript
const signature = await contract.erc721.tieredDrop.generate({
  tierPriority: ["tier-name"],
  to: "{{wallet_address}}",
  // highlight-next-line
  price: "{{price}}", // The user will have to pay `price * quantity` for minting the tokens
});
```

#### mintStartTime (optional)

The time from which the signature can be used to mint tokens.

Defaults to `Date.now()` (now).

```javascript
const signature = await contract.erc721.tieredDrop.generate({
  tierPriority: ["tier-name"],
  to: "{{wallet_address}}",
  // highlight-next-line
  mintStartTime: new Date(), // The user can mint the tokens from this time
});
```

#### mintEndTime (optional)

The time until which the signature can be used to mint tokens.

Defaults to `new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10),` (10 years from now).

```javascript
const signature = await contract.erc721.tieredDrop.generate({
  tierPriority: ["tier-name"],
  to: "{{wallet_address}}",
  // highlight-next-line
  mintEndTime: new Date(Date.now() + 60 * 60 * 24 * 1000), // The user can mint the tokens until this time
});
```

#### primarySaleRecipient (optional)

If a `price` is specified, the funds will be sent to the `primarySaleRecipient` address.

Defaults to the `primarySaleRecipient` address of the contract.

```javascript
const signature = await contract.erc721.tieredDrop.generate({
  tierPriority: ["tier-name"],
  to: "{{wallet_address}}",
  price: "{{price}}",
  // highlight-next-line
  primarySaleRecipient: "{{wallet_address}}", // The funds will be sent to this address
});
```

#### royaltyBps (optional)

The percentage fee you want to charge for secondary sales.

Defaults to the `royaltyBps` of the contract.

```javascript
const signature = await contract.erc721.tieredDrop.generate({
  tierPriority: ["tier-name"],
  to: "{{wallet_address}}",
  // highlight-next-line
  royaltyBps: 500, // A 5% royalty fee.
});
```

#### royaltyRecipient (optional)

The address that will receive the royalty fees from secondary sales.

Defaults to the `royaltyRecipient` address of the contract.

```javascript
const signature = await contract.erc721.tieredDrop.generate({
  tierPriority: ["tier-name"],
  to: "{{wallet_address}}",
  royaltyBps: 500, // A 5% royalty fee.
  // highlight-next-line
  royaltyRecipient: "{{wallet_address}}", // The royalty fees will be sent to this address
});
```

#### quantity (optional)

The number of tokens this signature can be used to mint.

```javascript
const signature = await contract.erc721.tieredDrop.generate({
  tierPriority: ["tier-name"],
  to: "{{wallet_address}}",
  // highlight-next-line
  quantity: "{{quantity}}",
});
```

</div>
</details>

## generateBatch

The same as [`generate`](#generate), but allows you to generate multiepl signatures at once.

```javascript
const signedPayloads = await contract.erc721.tieredDrop.generateBatch([
  {
    tierPriority: ["tier-name"],
    to: "{{wallet_address}}",
  },
  {
    tierPriority: ["tier-name"],
    to: "{{wallet_address}}",
  },
]);
```

<details>
  <summary>Configuration</summary>
  <div>

#### payloadsToSign

An array of objects containing the configuration options for each signature.

See [`generate`](#generate) for the configuration options available for each signature.

</div>
</details>

## getMetadataInTier

Get the metadata of NFTs in a tier.

```javascript
const metadatas = await contract.erc721.tieredDrop.getMetadataInTier(
  "tier-name",
);
```

<details>
    <summary>Configuration</summary>
    <div>

#### tier

The tier to get the NFT metadata for.

Must be a `string`.

### Return Value

If the tier cannot be found, returns `undefined`.

Otherwise, returns an array of `NFTMetadata` objects containing the metadata of the NFTs in the tier.

```typescript
{
    uri: string; // The raw URI of the metadata
    owner: string;
    name?: string | number | undefined;
    description?: string | null | undefined;
    image?: string | null | undefined; // If the image is hosted on IPFS, the URL is https://gateway.ipfscdn.io/ipfs/<hash>
    external_url?: string | null | undefined;
    animation_url?: string | null | undefined;
    background_color?: string | undefined;
    properties?: {
        [x: string]: unknown;
    } | {
        [x: string]: unknown;
    }[] | undefined;
}[]
```

</div>
</details>

## getTokensInTier

Get the information about NFTs in a tier.

```javascript
const tokens = await contract.erc721.tieredDrop.getTokensInTier("tier-name");
```

<details>
    <summary>Configuration</summary>
    <div>

#### tier

The tier to get the NFTs for.

Must be a `string`.

### Return Value

Returns an array of `NFT` objects containing the NFT metadata.

Returns an `NFT` object containing the NFT metadata and other information about the NFT.

```typescript
{
  metadata: {
    id: string;
    uri: string; // The raw URI of the metadata
    owner: string;
    name?: string | number | undefined;
    description?: string | null | undefined;
    image?: string | null | undefined; // If the image is hosted on IPFS, the URL is https://gateway.ipfscdn.io/ipfs/<hash>
    external_url?: string | null | undefined;
    animation_url?: string | null | undefined;
    background_color?: string | undefined;
    properties?: {
        [x: string]: unknown;
    } | {
        [x: string]: unknown;
    }[] | undefined;
  };
  type: "ERC721";
}[]
```

</div>
</details>

## reveal

Reveal a batch of NFTs that were lazy minted with
[`createDelayedRevealBatchWithTier`](#createdelayedrevealbatchwithtier).

```javascript
const txResult = await contract.erc721.tieredDrop.reveal(
  "{{batch_id}}", // ID of the batch to reveal
  "my secret password", // The password used to reveal the batch
);
```

<details>
    <summary>Configuration</summary>
    <div>

#### batchId

The ID of the batch to reveal.

Must be a `string`, `number`, or `BigNumber`.

#### password

The password you set when creating the batch.

Must be a `string`.

</div>
</details>

## verify

Verify that a payload is correctly signed.

This allows you to provide a payload, and prove that it was valid and was generated
by a wallet with permission to generate signatures.

```javascript
// Provide the generated payload to verify that it is valid
const isValid = await contract.erc721.tieredDrop.verify(payload);
```

<details>
  <summary>Configuration</summary>
  <div>

#### payload (required)

The payload to verify.

Must be of type `TieredDropPayloadWithSignature`.

### Return Value

Returns `true` if the payload is valid, `false` otherwise.

```typescript
boolean;
```

</div>
</details>
